// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ActivateMarket extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ActivateMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ActivateMarket must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ActivateMarket", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ActivateMarket | null {
    return changetype<ActivateMarket | null>(
      store.get("ActivateMarket", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value!.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ActivatePosition extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ActivatePosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ActivatePosition must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ActivatePosition", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ActivatePosition | null {
    return changetype<ActivatePosition | null>(
      store.get("ActivatePosition", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get premium(): BigInt {
    let value = this.get("premium");
    return value!.toBigInt();
  }

  set premium(value: BigInt) {
    this.set("premium", Value.fromBigInt(value));
  }

  get excessPremium(): BigInt {
    let value = this.get("excessPremium");
    return value!.toBigInt();
  }

  set excessPremium(value: BigInt) {
    this.set("excessPremium", Value.fromBigInt(value));
  }

  get delta(): BigInt {
    let value = this.get("delta");
    return value!.toBigInt();
  }

  set delta(value: BigInt) {
    this.set("delta", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CancelPosition extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelPosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CancelPosition must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CancelPosition", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CancelPosition | null {
    return changetype<CancelPosition | null>(
      store.get("CancelPosition", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get returnedPremium(): BigInt {
    let value = this.get("returnedPremium");
    return value!.toBigInt();
  }

  set returnedPremium(value: BigInt) {
    this.set("returnedPremium", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CreateMarket extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CreateMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CreateMarket must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CreateMarket", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CreateMarket | null {
    return changetype<CreateMarket | null>(
      store.get("CreateMarket", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get weight(): BigInt {
    let value = this.get("weight");
    return value!.toBigInt();
  }

  set weight(value: BigInt) {
    this.set("weight", Value.fromBigInt(value));
  }

  get optionToken(): Bytes {
    let value = this.get("optionToken");
    return value!.toBytes();
  }

  set optionToken(value: Bytes) {
    this.set("optionToken", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CreateStrike extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CreateStrike entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CreateStrike must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CreateStrike", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CreateStrike | null {
    return changetype<CreateStrike | null>(
      store.get("CreateStrike", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get strikeId(): BigInt {
    let value = this.get("strikeId");
    return value!.toBigInt();
  }

  set strikeId(value: BigInt) {
    this.set("strikeId", Value.fromBigInt(value));
  }

  get duration(): BigInt {
    let value = this.get("duration");
    return value!.toBigInt();
  }

  set duration(value: BigInt) {
    this.set("duration", Value.fromBigInt(value));
  }

  get expiration(): BigInt {
    let value = this.get("expiration");
    return value!.toBigInt();
  }

  set expiration(value: BigInt) {
    this.set("expiration", Value.fromBigInt(value));
  }

  get entryPrice(): BigInt {
    let value = this.get("entryPrice");
    return value!.toBigInt();
  }

  set entryPrice(value: BigInt) {
    this.set("entryPrice", Value.fromBigInt(value));
  }

  get strikePrice(): BigInt {
    let value = this.get("strikePrice");
    return value!.toBigInt();
  }

  set strikePrice(value: BigInt) {
    this.set("strikePrice", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DeactivateMarket extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DeactivateMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DeactivateMarket must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DeactivateMarket", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DeactivateMarket | null {
    return changetype<DeactivateMarket | null>(
      store.get("DeactivateMarket", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value!.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DefreezeMarket extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DefreezeMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DefreezeMarket must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DefreezeMarket", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DefreezeMarket | null {
    return changetype<DefreezeMarket | null>(
      store.get("DefreezeMarket", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value!.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DestoryStrike extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DestoryStrike entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DestoryStrike must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DestoryStrike", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DestoryStrike | null {
    return changetype<DestoryStrike | null>(
      store.get("DestoryStrike", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get strikeId(): BigInt {
    let value = this.get("strikeId");
    return value!.toBigInt();
  }

  set strikeId(value: BigInt) {
    this.set("strikeId", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ExercisePosition extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExercisePosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ExercisePosition must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExercisePosition", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ExercisePosition | null {
    return changetype<ExercisePosition | null>(
      store.get("ExercisePosition", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get revenue(): BigInt {
    let value = this.get("revenue");
    return value!.toBigInt();
  }

  set revenue(value: BigInt) {
    this.set("revenue", Value.fromBigInt(value));
  }

  get exerciseFee(): BigInt {
    let value = this.get("exerciseFee");
    return value!.toBigInt();
  }

  set exerciseFee(value: BigInt) {
    this.set("exerciseFee", Value.fromBigInt(value));
  }

  get settlementPrice(): BigInt {
    let value = this.get("settlementPrice");
    return value!.toBigInt();
  }

  set settlementPrice(value: BigInt) {
    this.set("settlementPrice", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ExpirePosition extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExpirePosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ExpirePosition must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExpirePosition", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ExpirePosition | null {
    return changetype<ExpirePosition | null>(
      store.get("ExpirePosition", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get settlementPrice(): BigInt {
    let value = this.get("settlementPrice");
    return value!.toBigInt();
  }

  set settlementPrice(value: BigInt) {
    this.set("settlementPrice", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FailPosition extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FailPosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FailPosition must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FailPosition", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FailPosition | null {
    return changetype<FailPosition | null>(
      store.get("FailPosition", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get returnedPremium(): BigInt {
    let value = this.get("returnedPremium");
    return value!.toBigInt();
  }

  set returnedPremium(value: BigInt) {
    this.set("returnedPremium", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FreezeMarket extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FreezeMarket entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type FreezeMarket must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FreezeMarket", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): FreezeMarket | null {
    return changetype<FreezeMarket | null>(
      store.get("FreezeMarket", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value!.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class KeeperAddressUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save KeeperAddressUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type KeeperAddressUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("KeeperAddressUpdated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): KeeperAddressUpdated | null {
    return changetype<KeeperAddressUpdated | null>(
      store.get("KeeperAddressUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get keeperAddress(): Bytes {
    let value = this.get("keeperAddress");
    return value!.toBytes();
  }

  set keeperAddress(value: Bytes) {
    this.set("keeperAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OpenPosition extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OpenPosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OpenPosition must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OpenPosition", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OpenPosition | null {
    return changetype<OpenPosition | null>(
      store.get("OpenPosition", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    return value!.toBytes();
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value!.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }

  get collection(): Bytes {
    let value = this.get("collection");
    return value!.toBytes();
  }

  set collection(value: Bytes) {
    this.set("collection", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get parameters_optionType(): i32 {
    let value = this.get("parameters_optionType");
    return value!.toI32();
  }

  set parameters_optionType(value: i32) {
    this.set("parameters_optionType", Value.fromI32(value));
  }

  get parameters_expiration(): BigInt {
    let value = this.get("parameters_expiration");
    return value!.toBigInt();
  }

  set parameters_expiration(value: BigInt) {
    this.set("parameters_expiration", Value.fromBigInt(value));
  }

  get parameters_entryPrice(): BigInt {
    let value = this.get("parameters_entryPrice");
    return value!.toBigInt();
  }

  set parameters_entryPrice(value: BigInt) {
    this.set("parameters_entryPrice", Value.fromBigInt(value));
  }

  get parameters_strikePrice(): BigInt {
    let value = this.get("parameters_strikePrice");
    return value!.toBigInt();
  }

  set parameters_strikePrice(value: BigInt) {
    this.set("parameters_strikePrice", Value.fromBigInt(value));
  }

  get parameters_amount(): BigInt {
    let value = this.get("parameters_amount");
    return value!.toBigInt();
  }

  set parameters_amount(value: BigInt) {
    this.set("parameters_amount", Value.fromBigInt(value));
  }

  get parameters_premium(): BigInt {
    let value = this.get("parameters_premium");
    return value!.toBigInt();
  }

  set parameters_premium(value: BigInt) {
    this.set("parameters_premium", Value.fromBigInt(value));
  }

  get parameters_keeperFee(): BigInt {
    let value = this.get("parameters_keeperFee");
    return value!.toBigInt();
  }

  set parameters_keeperFee(value: BigInt) {
    this.set("parameters_keeperFee", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PauseVault extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PauseVault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PauseVault must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PauseVault", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PauseVault | null {
    return changetype<PauseVault | null>(
      store.get("PauseVault", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value!.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Paused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Paused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Paused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Paused", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Paused | null {
    return changetype<Paused | null>(store.get("Paused", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class UnpauseVault extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UnpauseVault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type UnpauseVault must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UnpauseVault", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): UnpauseVault | null {
    return changetype<UnpauseVault | null>(
      store.get("UnpauseVault", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value!.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Unpaused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Unpaused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Unpaused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Unpaused", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Unpaused | null {
    return changetype<Unpaused | null>(store.get("Unpaused", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class UpdateLPTokenPrice extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UpdateLPTokenPrice entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type UpdateLPTokenPrice must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UpdateLPTokenPrice", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): UpdateLPTokenPrice | null {
    return changetype<UpdateLPTokenPrice | null>(
      store.get("UpdateLPTokenPrice", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lpToken(): Bytes {
    let value = this.get("lpToken");
    return value!.toBytes();
  }

  set lpToken(value: Bytes) {
    this.set("lpToken", Value.fromBytes(value));
  }

  get newPrice(): BigInt {
    let value = this.get("newPrice");
    return value!.toBigInt();
  }

  set newPrice(value: BigInt) {
    this.set("newPrice", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OptionPosition extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OptionPosition entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type OptionPosition must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OptionPosition", id.toString(), this);
    }
  }

  static load(id: string): OptionPosition | null {
    return changetype<OptionPosition | null>(store.get("OptionPosition", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get status(): string {
    let value = this.get("status");
    return value!.toString();
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get receiverAddress(): Bytes {
    let value = this.get("receiverAddress");
    return value!.toBytes();
  }

  set receiverAddress(value: Bytes) {
    this.set("receiverAddress", Value.fromBytes(value));
  }

  get callerAddress(): Bytes {
    let value = this.get("callerAddress");
    return value!.toBytes();
  }

  set callerAddress(value: Bytes) {
    this.set("callerAddress", Value.fromBytes(value));
  }

  get collectionAddress(): Bytes {
    let value = this.get("collectionAddress");
    return value!.toBytes();
  }

  set collectionAddress(value: Bytes) {
    this.set("collectionAddress", Value.fromBytes(value));
  }

  get positionId(): BigInt {
    let value = this.get("positionId");
    return value!.toBigInt();
  }

  set positionId(value: BigInt) {
    this.set("positionId", Value.fromBigInt(value));
  }

  get optionType(): i32 {
    let value = this.get("optionType");
    return value!.toI32();
  }

  set optionType(value: i32) {
    this.set("optionType", Value.fromI32(value));
  }

  get expiration(): BigInt {
    let value = this.get("expiration");
    return value!.toBigInt();
  }

  set expiration(value: BigInt) {
    this.set("expiration", Value.fromBigInt(value));
  }

  get entryPrice(): BigInt {
    let value = this.get("entryPrice");
    return value!.toBigInt();
  }

  set entryPrice(value: BigInt) {
    this.set("entryPrice", Value.fromBigInt(value));
  }

  get strikePrice(): BigInt {
    let value = this.get("strikePrice");
    return value!.toBigInt();
  }

  set strikePrice(value: BigInt) {
    this.set("strikePrice", Value.fromBigInt(value));
  }

  get delta(): BigInt {
    let value = this.get("delta");
    return value!.toBigInt();
  }

  set delta(value: BigInt) {
    this.set("delta", Value.fromBigInt(value));
  }

  get settlementPrice(): BigInt {
    let value = this.get("settlementPrice");
    return value!.toBigInt();
  }

  set settlementPrice(value: BigInt) {
    this.set("settlementPrice", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get premium(): BigInt {
    let value = this.get("premium");
    return value!.toBigInt();
  }

  set premium(value: BigInt) {
    this.set("premium", Value.fromBigInt(value));
  }

  get excessPremium(): BigInt {
    let value = this.get("excessPremium");
    return value!.toBigInt();
  }

  set excessPremium(value: BigInt) {
    this.set("excessPremium", Value.fromBigInt(value));
  }

  get returnedPremium(): BigInt {
    let value = this.get("returnedPremium");
    return value!.toBigInt();
  }

  set returnedPremium(value: BigInt) {
    this.set("returnedPremium", Value.fromBigInt(value));
  }

  get keeperFee(): BigInt {
    let value = this.get("keeperFee");
    return value!.toBigInt();
  }

  set keeperFee(value: BigInt) {
    this.set("keeperFee", Value.fromBigInt(value));
  }

  get revenue(): BigInt {
    let value = this.get("revenue");
    return value!.toBigInt();
  }

  set revenue(value: BigInt) {
    this.set("revenue", Value.fromBigInt(value));
  }

  get exerciseFee(): BigInt {
    let value = this.get("exerciseFee");
    return value!.toBigInt();
  }

  set exerciseFee(value: BigInt) {
    this.set("exerciseFee", Value.fromBigInt(value));
  }

  get updateTimestamp(): i32 {
    let value = this.get("updateTimestamp");
    return value!.toI32();
  }

  set updateTimestamp(value: i32) {
    this.set("updateTimestamp", Value.fromI32(value));
  }

  get createTimestamp(): i32 {
    let value = this.get("createTimestamp");
    return value!.toI32();
  }

  set createTimestamp(value: i32) {
    this.set("createTimestamp", Value.fromI32(value));
  }
}

export class Vault extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Vault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Vault must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Vault", id.toString(), this);
    }
  }

  static load(id: string): Vault | null {
    return changetype<Vault | null>(store.get("Vault", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalTradingVolume(): BigInt {
    let value = this.get("totalTradingVolume");
    return value!.toBigInt();
  }

  set totalTradingVolume(value: BigInt) {
    this.set("totalTradingVolume", Value.fromBigInt(value));
  }

  get totalPremiumCollected(): BigInt {
    let value = this.get("totalPremiumCollected");
    return value!.toBigInt();
  }

  set totalPremiumCollected(value: BigInt) {
    this.set("totalPremiumCollected", Value.fromBigInt(value));
  }

  get totalTrades(): i32 {
    let value = this.get("totalTrades");
    return value!.toI32();
  }

  set totalTrades(value: i32) {
    this.set("totalTrades", Value.fromI32(value));
  }

  get updateTimestamp(): i32 {
    let value = this.get("updateTimestamp");
    return value!.toI32();
  }

  set updateTimestamp(value: i32) {
    this.set("updateTimestamp", Value.fromI32(value));
  }

  get createTimestamp(): i32 {
    let value = this.get("createTimestamp");
    return value!.toI32();
  }

  set createTimestamp(value: i32) {
    this.set("createTimestamp", Value.fromI32(value));
  }
}

export class Trader extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Trader entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Trader must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Trader", id.toString(), this);
    }
  }

  static load(id: string): Trader | null {
    return changetype<Trader | null>(store.get("Trader", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get totalTrades(): i32 {
    let value = this.get("totalTrades");
    return value!.toI32();
  }

  set totalTrades(value: i32) {
    this.set("totalTrades", Value.fromI32(value));
  }

  get totalExercisedOptionPosition(): i32 {
    let value = this.get("totalExercisedOptionPosition");
    return value!.toI32();
  }

  set totalExercisedOptionPosition(value: i32) {
    this.set("totalExercisedOptionPosition", Value.fromI32(value));
  }

  get depositAmount(): BigInt {
    let value = this.get("depositAmount");
    return value!.toBigInt();
  }

  set depositAmount(value: BigInt) {
    this.set("depositAmount", Value.fromBigInt(value));
  }

  get totalRevenue(): BigInt {
    let value = this.get("totalRevenue");
    return value!.toBigInt();
  }

  set totalRevenue(value: BigInt) {
    this.set("totalRevenue", Value.fromBigInt(value));
  }

  get totalVolume(): BigInt {
    let value = this.get("totalVolume");
    return value!.toBigInt();
  }

  set totalVolume(value: BigInt) {
    this.set("totalVolume", Value.fromBigInt(value));
  }

  get totalPremium(): BigInt {
    let value = this.get("totalPremium");
    return value!.toBigInt();
  }

  set totalPremium(value: BigInt) {
    this.set("totalPremium", Value.fromBigInt(value));
  }

  get updateTimestamp(): i32 {
    let value = this.get("updateTimestamp");
    return value!.toI32();
  }

  set updateTimestamp(value: i32) {
    this.set("updateTimestamp", Value.fromI32(value));
  }

  get createTimestamp(): i32 {
    let value = this.get("createTimestamp");
    return value!.toI32();
  }

  set createTimestamp(value: i32) {
    this.set("createTimestamp", Value.fromI32(value));
  }
}
